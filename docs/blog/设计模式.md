## 简单工厂模式

> 由一个对象决定创建某一种产品对象类的实例，主要用来创建同一类对象。（只关心创建结果）

## 建造者模式

> 将一个复杂对象的构建层与其表示层相互分离，同样的构建过程可采用不同的表示。（参与创建的具体过程）

## 原型模式

> 用原型实例指向创建对象的类，使用于创建新的对象的类共享原型对象的属性以及方法。（类似原型继承prototype）

## 单例模式

> 只允许实例化一次的对象类，有时我们也用一个对象来规划一个命名空间，仅仅有条的管理对象上的属性和方法。

## 外观模式

> 为一组复杂的子系统接口提供一个更高级的统一接口，通过这个接口使得对子系统接口的访问更加容易。

> （在js中有时候会用于对底层结构兼容性做统一的封装来简化用户的使用，例如：兼容 addEventListener attachEvent）

## 适配器模式

> 将一个类的接口转化为另外一个接口，以满足用户需求，使类之间接口不兼容问题通过适配器得以解决。

> （适配对象，适配代码库，适配数据等）

## 代理模式

> 由于一个对象不能直接引用另一个对象，所以需要通过代理对象在这两个对象之间起到中介的作用。

> （例如：ajax跨域，通过jsonp做代理，即可解决）

## 装饰器模式

> 在不改变原对象的基础上，通过对其进行包装扩展（添加属性或方法）使原有对象可以满足用户的更复杂需求。

> （例如：增加属性，扩展原方法等）

## 桥接模式


> 桥接模式（Bridge）将抽象部分与它的实现部分分离，使它们都可以独立地变化。

> （一个实现未必不变地绑定在一个接口上，抽象类（函数）的实现可以在运行时刻进行配置，一个对象甚至可以在运行时刻改变它的实现，同将抽象和实现也进行了充分的解耦，也有利于分层，从而产生更好的结构化系统。）主要用于解耦


## 组合模式

> 又称部分-整体模式，想对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。

> （组合模式通过继承同一父类，使其具有统一的方法，便于统一管理和使用，结构清晰）

## 享元模式

> 运用共享技术有效的支持大量的细粒度对象，避免对象间拥有相同内容造成多余开销。

> （例如：性能优化，分页显示，只需操作一页的DOM）

## 模板方法模式

> 父类中定义一组操作算法骨架，而将一些实现步骤延迟到了子类中，使得子类可以不改变父类的算法结构的同事可更新定义算法中某些实现步骤

>（类似后端的Interface）

## 观察者模式

> 又被称为发布——订阅者模式，定义了一种依赖关系，解决了主题对象与观察者之间功能的耦合。

> (解决类和对象之间的耦合，解耦2个相互因爱的对象，使其依赖于观察者的消息机制)

## 状态模式

> 当一个对象的内部状态发生改变时，会导致其行为的改变，这看起来像是改变了对象。

> （解决程序中臃肿的分支判断语句问题，将每一个分支转化为一种状态独立出来）

## 策略模式

> 将定义的一组算法封装起来，使其相互之间可以替换，封装的算法具有一定的独立性，不会随客户端变化而变化。

> （每组算法处理的业务是相同的。）

## 职责链模式

> 解决请求的发送者与请求的接受者之间的耦合，通过职责链的多个对象分解请求流程，实现请求在多个对象之间的传递，直到最后一个对象完成请求的处理。

> （需求拆解，每个模块功能单一，依次执行模块）

## 命令模式

> 将请求与实现解耦并封装成独立的对象，从而使不同的请求对客户端的实现参数化。

> （解耦，命令发起者和执行者。）

## 访问者模式

> 针对于对象结构中的元素，定义在不改变该对象的前提下，访问结构中元素的新方法。

> （解决数据与数据操作方法之间的耦合，将数据的操作方法独立于数据，使其可以自由化演变）

## 中介者模式

> 通过中介者对象封装一系列对象之间的交互，是对象之间不再相互引用，降低他们之间的耦合，有时中介者对象也可以改变对象之间的交互。 

> （类似于观察者模式，但是单向的，由中介者统一管理）

## 备忘录模式

> 在不破坏对象的封装性的前提下，在对象之外捕获并保存该对象内部的状态，以便日后对象使用或者对象恢复到之前的某个状态。

> （分页加载，对已加载的页进行缓存）

## 迭代器模式

> 在不暴露对象内部结构的同事，可以顺序地访问聚合对象内部的元素。

> （隐形地将循环语句移到了迭代器中）

## 解释器模式

> 对于一种语言，给出其文法表示形式，并定义一种解释器，通过使用这种解释器，来解释语言中定义的句子。

> （解析dom树html>head|body>button）

## 数据访问对象模式

> 抽象和封装对数据源的访问和存储，DAO通过对象数据源链接的管理，方便对数据的访问和存储。

> （封装操作数据库层DAO）

## MVC模式

> view->controller->model->view

> (在MVC，当你有变化的时候你需要同时维护三个对象和三个交互，这显然让事情复杂化了)

![MVC模式]({{ site.baseurl }}/assets/img/blog/mvc.png)

## MVP模式

> view->presenter->model->presenter->view

> (MVP与MVC有着一个重大的区别：在MVP中View并不直接使用Model，它们之间的通信是通过Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部，而在MVC中View会直接从Model中读取数据而不是通过 Controller。)

![MVP模式]({{ site.baseurl }}/assets/img/blog/mvp.png)

## MVVM模式

> view<->viewModel->model->viewModel<->view

> (MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。)

![MVVM模式]({{ site.baseurl }}/assets/img/blog/mvvm.png)
